;;; Converts abstract problems to Sandia SPM problems
;;;
;;;

(defparameter *sandia-features* '((a . shape)
				  (b . background)
				  (c . orientation)
				  (d . texture)  ;; Should be 'size
				  (e . number)))

(defparameter *sandia-rules* '((1 . same-row)
			       (2 . same-column)
			       (3 . diagonal1)
			       (4 . diagonal2)))


(defparameter *distribution-rules* '((1 . (1 1 1 2 2 2 3 3 3))
				     (2 . (1 2 3 1 2 3 1 2 3))
				     (3 . (1 2 3 3 1 2 2 3 1))
				     (4 . (1 2 3 2 3 1 3 1 2))))


(defun generate-image-name (trl &optional (phase 'problem))
  (if (equal phase 'problem)
      (format nil "~A.gif" (trial-metadata trl))
      (format nil "~A_Answers.gif" (trial-metadata trl))))
  

(defun make-square (vec)
  (when (= (length vec) 9)
    (let ((result nil))
      (dotimes (r 3 (reverse result))
	(let ((row nil))
	  (dotimes (c 3)
	    (push (nth (+ c (* 3 r)) vec)
		  row))
	  (push (reverse row) result))))))

(defun create-feature-distribution-from-code (code)
  (let* ((feature-code (first code))
	 (distribution-code (second code))
	 (feat (cdr (assoc feature-code *sandia-features*)))
	 (distribution (cdr (assoc distribution-code *distribution-rules*))))
    (mapcar #'(lambda (x) (list feat x))
	    distribution)))


(defparameter *matzen-subset*
  '(("A1B2" 1)
    ("A1B3" 1)
    ("A1B4" 1)
    ("A1D2" 1)
    ("A1D3" 1)
    ("A1D4" 1)
    ("A1E2" 1)
    ("A1E3" 1)
    ("A1E4" 1)
    ("A1" 1)
    ("A2B1" 1)
    ("A2B3" 1)
    ("A2B4" 1)
    ("A2D1" 1)
    ("A2D3" 1)
    ("A2D4" 1)
    ("A2E1" 1)
    ("A2E3" 1)
    ("A2E4" 1)
    ("A2" 1)
    ("A3B1" 1)
    ("A3B2D1" 1)
    ("A3B2" 1)
    ("A3B4" 1)
    ("A3D1" 1)
    ("A3D2" 1)
    ("A3D4" 1)
    ("A3E1" 1)
    ("A3E2" 1)
    ("A3E4" 1)
    ("A3" 1)
    ("A4B1" 1)
    ("A4B2E1" 1)
    ("A4B2" 1)
    ("A4B3" 1)
    ("A4D1E2" 1)
    ("A4D1" 1)
    ("A4D2" 1)
    ("A4D3" 1)
    ("A4E1" 1)
    ("A4E2" 1)
    ("A4E3" 1)
    ("A4" 1)
    ("B1D2" 1)
    ("B1D3" 1)
    ("B1D4" 1)
    ("B1E2" 1)
    ("B1E3" 1)
    ("B1E4" 1)
    ("B1" 1)
    ("B2D1" 1)
    ("B2D3" 1)
    ("B2D4" 1)
    ("B2E1" 1)
    ("B2E3" 1)
    ("B2E4" 1)
    ("B2" 1)
    ("B3D1" 1)
    ("B3D2" 1)
    ("B3D4" 1)
    ("B3E1" 1)
    ("B3E2" 1)
    ("B3E4" 1)
    ("B3" 1)
    ("B4D1" 1)
    ("B4D2" 1)
    ("B4D3" 1)
    ("B4E1" 1)
    ("B4E2" 1)
    ("B4E3" 1)
    ("B4" 1)
    ("D1E2" 1)
    ("D1E3" 1)
    ("D1E4" 1)
    ("D1" 1)
    ("D2E1" 1)
    ("D2E3" 1)
    ("D2E4" 1)
    ("D2" 1)
    ("D3E1" 1)
    ("D3E2" 1)
    ("D3E4" 1)
    ("D3" 1)
    ("D4E1" 1)
    ("D4E2" 1)
    ("D4E3" 1)
    ("D4" 1)
    ("E1" 1)
    ("E2" 1)
    ("E3" 1)
    ("E4" 1))
  "List of problems selected from Matzen's set of 1000")


(defun expand-code (str)
  "Expands a Matzen code string into a lisp list"
  (let* ((char-list (map-into (make-sequence 'list (length str))
			      #'(lambda (x) x) str))
	 (sym-list (mapcar #'(lambda (x) (read-from-string (format nil "~A" x)))
			   char-list)))
    (divide-into-pairs sym-list))) 


(defun generate-problem-from-matzen-code (code)
  (let* ((feats (mapcar #'create-feature-distribution-from-code
			(expand-code code)))
	 (raw-cells (reduce #'(lambda (x y) (mapcar #'append x y)) feats))
	 (paired-cells (mapcar #'divide-into-pairs raw-cells))
	 (paired-features (mapcar #'(lambda (cell)
				      (mapcar #'(lambda (fv-pair)
						  (list (first fv-pair)
							(assoc-value (first fv-pair)
								     (second fv-pair))))
					      cell))
				  paired-cells)))
    (make-square (mapcar #'flatten paired-features))))
    

(defun generate-trial-from-matzen-code (code &optional (solution-position nil))
  "Generates a trial from a Matzen problem's metadata (e.g., A3B1D2, 3)"
  (let* ((problem (generate-problem-from-matzen-code code))
	 (correct (problem-cell problem 2 2))
	 (options (generate-options problem solution-position)))
    (setf (nth 2 (nth 2 problem)) nil)
    (list problem correct options code)))

(defun generate-matzen-trials ()
  (mapcar #'(lambda (x) (generate-trial-from-matzen-code (first x) (second x)))
	  ;;*matzen-subset*))
	  (remove-if #'(lambda (x) (or (find #\3 x)
				       (find #\4 x))) *matzen-subset* :key #'first)))

(defun rapm-demo (&optional (visicon t))
  "Reloads the model and sets up the experiment (and optionally prints the visicon)"
  (reload)
  (install-device (make-instance 'rapm-task))
  (setf (trials (current-device)) (generate-matzen-trials)) 
  (init (current-device))
  (proc-display)
  (when visicon ;; Prints the visicon 
    (print-visicon)))

